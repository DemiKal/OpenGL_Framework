
#version 430 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D img_output;
layout(binding = 1) uniform sampler2D  texture_diffuse1;


const int StackSize = 32;
const int LEAFSIZE = 2;

uniform bool u_shadowCast;
uniform bool u_useZbuffer;
uniform bool u_linearizeZ;
uniform bool u_showNormal;

uniform float u_nearPlane;
uniform float u_far_plane;
uniform float u_aspectRatio;
uniform float u_screenWidth;
uniform float u_screenHeight;
uniform float u_ambientLight;
uniform float u_epsilon;

uniform vec3 u_cameraPos;
uniform vec3 u_viewDir;
uniform vec3 u_cameraUp;
uniform vec3 u_lightDir;
 
uniform mat4 u_inv_projMatrix;
uniform mat4 u_inv_viewMatrix; 
uniform mat4 u_InvTransform; 

struct Triangle { vec4 A, B, C;};

struct BVHNode { vec4 m_min; vec4 m_max; };

struct UV { vec2 a, b, c; };

layout (std430,  binding = 0) readonly buffer BVH_buffer 
{
	BVHNode BVH[] ;	
};

//layout (std430, binding = 1) readonly buffer Index_buffer
//{
//	uint tri_indices[] ;	
//};

layout (std430, binding = 1) readonly buffer Triangle_buffer
{
	Triangle triangles[] ;	
};

layout (std430, binding = 2) readonly buffer Texcoord_buffer
{
	UV texcoords [] ;	
};

struct AABB
{
	vec3 m_min;
	vec3 m_max;
};

struct HitData
{
	bool hasHit;
	float u,v, dist;
};

HitData triIntersect(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2)
{
	vec3 v1v0 = v1 - v0;
	vec3 v2v0 = v2 - v0;
	vec3 rov0 = ro - v0;

#if 0
	// Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)
	float d = 1.0 / determinant(mat3(v1v0, v2v0, -rd));
	float u = d * determinant(mat3(rov0, v2v0, -rd));
	float v = d * determinant(mat3(v1v0, rov0, -rd));
	float t = d * determinant(mat3(v1v0, v2v0, rov0));
#else
	// The four determinants above have lots of terms in common. Knowing the changing
	// the order of the columns/rows doesn't change the volume/determinant, and that
	// the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce
	// it all to:
	vec3  n = cross(v1v0, v2v0);
	vec3  q = cross(rov0, rd);
	float d = 1.0 / dot(rd, n);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-n, rov0);
#endif    

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		t = -1.0;

	return HitData(t > -1.0f, u , v, t); 
	 //vec3(t, u, v); 
}

bool IntersectAABB(vec3 rayOrigin, vec3 rayDirection, AABB bbox)
{
	//vec3  direction rayDirection;
	//vec3  origin = rayOrigin;

	vec3 d = vec3(
		1.0f / rayDirection.x,
		1.0f / rayDirection.y,
		1.0f / rayDirection.z);

	float t = 99999999.f;
	float tx1 = (bbox.m_min.x - rayOrigin.x) * d.x;
	float tx2 = (bbox.m_max.x - rayOrigin.x) * d.x;

	float tmin = min(tx1, tx2);
	float tmax = max(tx1, tx2);

	float ty1 = (bbox.m_min.y - rayOrigin.y) * d.y;
	float ty2 = (bbox.m_max.y - rayOrigin.y) * d.y;

	tmin = max(tmin, min(ty1, ty2));
	tmax = min(tmax, max(ty1, ty2));

	float tz1 = (bbox.m_min.z - rayOrigin.z) * d.z;
	float tz2 = (bbox.m_max.z - rayOrigin.z) * d.z;

	tmin = max(tmin, min(tz1, tz2));
	tmax = min(tmax, max(tz1, tz2));
	//tCurrent = tmin;
	//return vec3(tmax, tmin)
	return tmax >= max(0.0f, tmin) && tmin < t;
}


vec3 RayFromCam(float mouseX, float mouseY)
{
	float x = (2.0f * mouseX) / u_screenWidth - 1.0f;
	float y = 1.0f - (2.0f * mouseY) / u_screenHeight;
	float z = 1.0f;

	//normalized device coordinates [-1:1, -1:1, -1:1]
	vec3 ray_nds = vec3(x, y, z);

	// clip space (4d homogenized) [-1:1, -1:1, -1:1, -1:1]
	vec4 ray_clip = vec4(ray_nds.x, ray_nds.y, -1.0, 1.0);

	// eye space [-x:x, -y:y, -z:z, -w:w]
	vec4 ray_eye = u_inv_projMatrix * ray_clip;
	ray_eye = vec4(ray_eye.x, ray_eye.y, -1.0, 0.0);

	// world space [-x:x, -y:y, -z:z, -w:w]
	vec4 ray4_world = u_inv_viewMatrix * ray_eye;
	
	vec3 ray_world = normalize(ray4_world.xyz);

	//Ray ray(this->PositionRead(), ray_world);

	return ray_world;
}

struct BVHhit
{
	bool hasHit;
	int depth;
	float u;
	float v;
	float t;
	uint triIdx;
	int bbIdx;
};
 
BVHhit TraverseBVH(vec3 rayOrigin, vec3 rayDir)
{
	BVHhit result;

	 //int size = textureSize(u_indexTexture, 0);
	//int size = BVH.length();
	int currentIdx = 0;

	uint stackPtr[StackSize];
	stackPtr[0] = 0; //sentinel null guard value
	currentIdx++;

	//if( IntersectAABB(rayOrigin, rayDir, GetAABB(0) )) 
	//	return true;
	//else return false;
	bool hasHit = false;

	float t = 999999.f;
	float _u = 0;
	float _v = 0; 
	uint tri_idx = 0;
	uint leafidx = 0;
	//bool earlyExit = false;
	//loop---------------------------------------------------------------------------------------------------------------
	//-------------------------------------------------------------------------------------------------------------------
	while (currentIdx > 0 && currentIdx < StackSize)
	{
		uint bboxIdx = stackPtr[currentIdx - 1];
		currentIdx--;
 		BVHNode currentBVH = BVH[bboxIdx];

		uint childCount = floatBitsToUint(currentBVH.m_max.w); //currentBVH.m_count;
		uint leftFirst = floatBitsToUint(currentBVH.m_min.w);
		
		bool isInterior = childCount > LEAFSIZE; //TODO: leaf check
		leafidx += childCount;//vec3 BBmin = vec3(currentBVH.minX,currentBVH.minY,currentBVH.minZ);
		//vec3 BBmax = vec3(currentBVH.maxX,currentBVH.maxY,currentBVH.maxZ);
		// childCount;
		AABB currentAABB = AABB(currentBVH.m_min.xyz, currentBVH.m_max.xyz);  //GetAABB(bboxIdx);

		if (IntersectAABB(rayOrigin, rayDir, currentAABB))
		{
			if (isInterior)
			{
				
				uint rightFirst = leftFirst + 1;
				//BVHNode lBVH = BVH[leftChild];
				 
				//atomicCompSwap(leftFir)
				stackPtr[currentIdx++] = leftFirst;  //leftFirst ? leftChild  : rightChild;
				stackPtr[currentIdx++] = rightFirst;  //leftFirst ? rightChild : leftChild ;
			}
			else //leaf node
			{
				//uint nodeStart = floatBitsToUint(currentBVH.m_min.w);	//TODO: check if this can be omitted
				uint nodeStart = leftFirst;			//TODO: check if this can be omitted
				//uint nodeStart = bboxIdx;			//TODO: check if this can be omitted
				//uint nodeStart = currentIdx;		//TODO: check if this can be omitted
				//uint nodeStart = currentIdx;		//TODO: check if this can be omitted
				//uint nodeStart = leafidx;			
				
				for (uint i = 0; i < childCount; i++)
				{	
					uint j = nodeStart + i; 

					//uint tIdx = tri_indices[j];
					uint tIdx = j ;
					
					vec3 v0 = triangles[tIdx].A.xyz;
					vec3 v1 = triangles[tIdx].B.xyz;
					vec3 v2 = triangles[tIdx].C.xyz;

					HitData Thit = triIntersect(rayOrigin, rayDir, v0, v1, v2);

					float newT = Thit.dist;
					if (newT > 0 && newT >= u_epsilon)
					{
						hasHit = true;
						if (newT < t )
						{
							t = newT;
							_u = Thit.u;
							_v = Thit.v;
							tri_idx = tIdx;
						}
					} 
				}
			}
		}
	}
	 
	result.u = _u;
	result.v = _v;
	result.t = t;
	result.hasHit = hasHit; 
	result.triIdx = tri_idx;
	return result;
}

float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Back to NDC 
    return (2.0 * u_nearPlane * u_nearPlane) / 
	(u_far_plane + u_nearPlane - z * (u_far_plane - u_nearPlane));	
}

float LinearizeDepth2(float z)
{
	float n = u_nearPlane ; // camera z near
	float f = u_far_plane ; // camera z far
	//float z = texture2D(depthSampler, uv).x;
	return (2.0 * n) / (f + n - z * (f - n));	
}

void main()
{
	vec2 aspectRatio = vec2(u_aspectRatio, 1.0f);
	vec2 TexCoords = vec2(gl_GlobalInvocationID.xy) / vec2(u_screenWidth, u_screenHeight);
	vec2 scrnCoords = vec2((0.5f - TexCoords.xy)) * aspectRatio;

	vec3 scrnPlane = cross(u_cameraUp, u_viewDir);

	vec3 screenHoriz = scrnCoords.x * scrnPlane;
	vec3 screenVert = scrnCoords.y * -	u_cameraUp;

	vec2 pixelCoord = vec2(TexCoords.x, 1.0f - TexCoords.y) * vec2(u_screenWidth, u_screenHeight);
	vec2 perc = (2 * TexCoords) - vec2(1, 1);
	vec3 scrnPos = u_cameraPos + u_viewDir * u_nearPlane + screenHoriz + screenVert;
	vec3 rayPos = u_cameraPos;
	//vec3 rayDir = normalize(scrnPos - rayPos);
	vec3 rayDir = RayFromCam(pixelCoord.x, pixelCoord.y);
	rayDir = vec3(  (u_InvTransform) * vec4(rayDir, 0));
	rayPos = vec3(  (u_InvTransform) * vec4(rayPos, 1));
	//AABB aabb = AABB(BVH[0].m_min.xyz, BVH[0].m_max.xyz);

	vec4 finalColor = vec4(1, 1, 1, 1);

	BVHhit bvhR = TraverseBVH(rayPos, rayDir);
	if(bvhR.hasHit)
	{
		//finalColor = vec4(bvhR.u,bvhR.v, 1, 1);	
		UV tc = texcoords[bvhR.triIdx];
		float u = bvhR.u;
		float v = bvhR.v;
		vec2 uv = tc.a * (1.0 - (u + v)) + tc.b * (u) + (v ) * tc.c;
		finalColor = texture(texture_diffuse1, vec2( uv.x, uv.y)).rgba;
	}
	
	imageStore(img_output, ivec2(gl_GlobalInvocationID), finalColor);
}

